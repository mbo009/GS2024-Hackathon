import requests
from urllib.parse import urlencode, quote


def sql_injection(request, base_url, token, is_endpoint_secured):
    path = request.get("path")
    method = request.get("method", "GET").upper()
    parameters = request.get("parameters", [])
    request_body = request.get("requestBody", {})
    report_output = {"testType": "sql_injection", "passed": False, "endpoint": path}
    sql_sensitive_keys = [
        "id",
        "limit",
        "offset",
        "filter",
        "search",
        "query",
        "order",
        "sort",
    ]
    PAYLOADS = [
        "' OR 1=1--",
        "' UNION SELECT null, null, null--",
        "' AND 1=2--",
        # "' AND SLEEP(5)--",
    ]

    headers = {}
    # if token and is_endpoint_secured:
    headers["Authorization"] = f"Bearer {token}"

    for param in parameters:

        if (
            param["in"] in ["query", "path"]
            or param["name"].lower() in sql_sensitive_keys
        ):

            param_name = param["name"]
            for payload in PAYLOADS:
                if param["in"] == "query":

                    # Query parameter injection
                    test_params = {param_name: payload}
                    full_url = f"{base_url}{path}?{urlencode(test_params)}"
                    response = send_request(method, full_url, headers=headers)
                    if not analyze_response(response, payload, report_output):
                        return report_output
                elif param["in"] == "path":
                    # Path parameter injection
                    encoded_payload = quote(payload)  # Encode the payload
                    modified_path = path.replace(f"{{{param_name}}}", encoded_payload)
                    full_url = f"{base_url}{modified_path}"
                    response = send_request(method, full_url, headers=headers)
                    print(response)
                    if not analyze_response(response, payload, report_output):
                        return report_output

    if len(request_body) > 0:
        request_body = request_body[list(request_body.keys())[0]]
        # print(path, request_body)
        if "string" in str(request_body) or any(
            key in str(request_body).lower() for key in sql_sensitive_keys
        ):
            for payload in PAYLOADS:
                test_body = {
                    key: payload for key in request_body.get("properties", {}).keys()
                }
                # print(f"Testing Request Body: {base_url}{path} with body {test_body}")
                response = send_request(
                    method, f"{base_url}{path}", headers=headers, json=test_body
                )
                if not analyze_response(response, payload, report_output):
                    return report_output
    report_output["description"] = (
        "No SQL injections detected, vulnerabilities not found."
    )
    report_output["passed"] = True
    return report_output


def send_request(method, url, **kwargs):
    try:
        if method == "GET":
            # print(requests.get(url, **kwargs).json())
            return requests.get(url, **kwargs)
        elif method == "POST":
            # print(requests.post(url, **kwargs).json())
            return requests.post(url, **kwargs)
        elif method == "PUT":
            # print(requests.put(url, **kwargs).json())
            return requests.put(url, **kwargs)
        elif method == "DELETE":
            # print(requests.delete(url, **kwargs).json())
            return requests.delete(url, **kwargs)
    except requests.RequestException as e:
        print(f"Error sending request to {url}: {e}")
        return None


def analyze_response(response, payload, report_output):
    if response.status_code >= 500:
        report_output["description"] = (
            f"Possible SQL Injection Detected! Payload: {payload}"
        )
        return False
    if response:
        print(response.status_code)

        if "syntax error" in response.text.lower():
            report_output["description"] = (
                f"SQL Syntax Error Detected! Payload: {payload}"
            )
            return False
        elif "unclosed quotation" in response.text.lower():
            report_output["description"] = (
                f"Unclosed Quotation Found! Payload: {payload}"
            )
            return False
        elif response.elapsed.total_seconds() > 4:  # Time-based blind SQLi
            report_output["description"] = (
                f"Time-based SQL Injection Detected! Payload: {payload}"
            )
            return False
        else:
            # print(response)
            report_output["description"] = (
                f"Tested Payload: {payload} - No vulnerabilities detected."
            )
            return True
    else:

        return True
