import requests
import re
import time


def cmd_injection(request, base_url):
    report_output = {}

    def strip_bracketed_part(string, pattern):
        return re.sub(pattern, "", string)

    def check_string_format(string, pattern):
        return bool(re.match(pattern, string))

    pattern_match = r"^[^/]+/\{[^{}]*\}$"
    pattern_sub = r"/\{[^{}]*\}$"

    payloads = [
        "1; ls",  # List files in the server directory
        "1; whoami",  # Retrieve the current server user
        "1; cat /etc/passwd",  # Attempt to read sensitive files
        "1; sleep 10",  # Blind injection: Introduce delay
    ]
    threshold = 5
    if check_string_format(request["path"], pattern_match):
        path = strip_bracketed_part(request["path"], pattern_sub)
        for payload in payloads:
            url = f"{base_url}/{path}/{payload}"
            start_time = time.time()
            try:
                response = requests.get(url)
                elapsed_time = time.time() - start_time
                if not check_sleep(elapsed_time, threshold, report_output):
                    return report_output
                if not hasattr(response, "text"):
                    generate_passed_report(report_output)
                    return report_output
                if not check_ls(response.text, report_output):
                    return report_output
                if not check_whoami(response.text, report_output):
                    return report_output
                if not check_cat_passwd(response.text, report_output):
                    return report_output
                generate_passed_report(report_output)
                return report_output
            except Exception as e:
                report_output["description"] = f"Error testing payload {payload}: {e}"


def check_ls(response_text, report_output):
    potential_matches = [
        "file",
        "root",
        "config",
        "dockerfile",
        "deploy",
        "logs",
        "scripts",
        "data",
    ]
    for match in potential_matches:
        if match in response_text:
            generate_failed_report(report_output)
            return False
    return True


def check_sleep(elapsed_time, threshold, report_output):
    if elapsed_time > threshold:
        generate_failed_report(report_output)
        return False
    return True


def check_whoami(response_text, report_output):
    potential_matches = ["root", "nginx", "user", "superuser", "admin"]
    for match in potential_matches:
        if match in response_text:
            generate_failed_report(report_output)
            return False
    return True


def check_cat_passwd(response_text, report_output):
    if "root:x:0:0:" in response_text:
        generate_failed_report(report_output)
        return False
    return True


def generate_failed_report(report_output):
    report_output["testType"] = "cmd_injection"
    report_output["passed"] = False
    report_output["description"] = "Command output detected, possible vulnerability."


def generate_passed_report(report_output):
    report_output["testType"] = "cmd_injection"
    report_output["passed"] = True
    report_output["description"] = (
        "No command output detected, vulnerabilities not found."
    )
